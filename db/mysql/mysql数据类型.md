###  datetime 和 timestamp

```
1. 存储范围不同：datetime的存储范围是 1000-01-01 00:00:00.000000 到 9999-12-31 23:59:59.999999，而timestamp的范围是 
1970-01-01 00:00:01.000000 到 2038-01-19 03:14:07.999999；

2. datetime存储与时区无关，而timestamp存储的是与时区有关，这也是两者最大的不同。MySql在存储timestamp时会先将时间转为
UTC（世界协调时）进行存储，然后查询的时候再从UTC转为当前的时区进行返回。也就是说使用timestamp进行存储的时间返回的时候
会随着数据库的时区而发生改变。而datetime的存储则与时区无关，数据是什么，就存储什么，也就返回什么。

3. datetime适用于记录数据的创建时间，因为这个时间是不会变的。而timestamp有自动修改更新的功能，也就是说，我们对表里的其他
数据进行修改，timestamp修饰的字段会自动更新为当前的时间，这个特性称为自动初始化和自动更新(Automatic Initialization and
 Updating)。所以timestamp适用于那种记录数据的最后修改时间的字段。当然，我们也可以设置timestamp不自动更新，通过设置 
 explicit_defaults_for_timestamp配置，从OFF设置为ON 来实现。从MySql5.6.5之后，Automatic Initialization and Updating这种
 特性不但适用于timestamp，也适用于datetime了。并且以前MySql版本要求同一张表中满足该特性的timestamp只能有一个字段，而现在
 也不再限制数量了。

4. 时区信息是MySql的系统变量，我们可以通过 show variables like '%time_zone%' 来获取mysql的时区信息，默认值一般是 SYSTEM，
即服务器的时区。

5. 修改当前会话的时区只会影响到当前连接，如果再开一个连接，时区将仍是mysql默认时区。如果要修改整个mysql的时区，可以有多
种方式，比如修改my.ini配置等，然后记得重启即可。

```

### float 和 double
```
好的参考博客： http://yongxiong.leanote.com/post/mysql_float_double_decimal
对于单精度浮点数Float:  当数据范围在＋－131072（65536×2）以内的时候，float数据精度是正确的，但是超出这个范围的数据就不稳定，没有发现有相关的参数设置建议：将float改成double或者decimal，两者的差别是double是浮点计算，decimal是定点计算，会得到更精确的数据。
分析如下：
一、浮点数的概念及误差问题：   
    浮点数是用来表示实数的一种方法，它用 M(尾数) * B( 基数)的E(指数）次方来表示实数，相对于定点数来说，在长度一定的情况下，具有表示数据范围大的特点。但同时也存在误差问题，这就是著名的浮点数精度问题！   
     浮点数有多种实现方法，计算机中浮点数的实现大都遵从 IEEE754 标准，IEEE754 规定了单精度浮点数和双精度浮点数两种规格，单精度浮点数用4字节（32bit）表示浮点数，格式是：1位符号位 8位表示指数 23位表示尾数；双精度浮点数8字节（64bit）表示实数，格式是：1位符号位 11位表示指数 52位表示尾数。同时，IEEE754标准还对尾数的格式做了规范：d.dddddd...，小数点左面只有1位且不能为零，计算机内部是二进制，因此，尾数小数点左面部分总是1。显然，这个1可以省去，以提高尾数的精度。由上可知，单精度浮点数的尾数是用24bit表示的，双精度浮点数的尾数是用53bit表示的，转换成十进制：
    
    2^24 - 1 = 16777215           
    2^53 - 1 = 9007199254740991     
    
    由上可见，IEEE754单精度浮点数的有效数字二进制是24位，按十进制来说，是8位；双精度浮点数的有效数字二进制是53位，按十进制来说，是16 位。
    显然，如果一个实数的有效数字超过8位，用单精度浮点数来表示的话，就会产生误差！同样，如果一个实数的有效数字超过16位，用双精度浮点数来表示，也会产生误差！
    例如：对于 1310720000000000000000.66 这个数，有效数字是24位，用单精度或双精度浮点数表示都会产生误差，只是程度不同：   
    
    单精度浮点数： 1310720040000000000000.00   
    双精度浮点数： 1310720000000000000000.00   
    
    双精度差了 0.66 ，单精度差了近4万亿！以上说明了因长度限制而造成的误差，但这还不是全部！采用IEEE754标准的计算机浮点数，在内部是用二进制表示的，但在将一个十进制数转换为二进制浮点数时，也会造成误差，原因是不是所有的数都能转换成有限长度的二进制数。对于131072.32 这个数，其有效数字是8位，按理应该能用单精度浮点数准确表示，为什么会出现偏差呢？看一下这个数据二进制尾数就明白了 10000000000000000001010001......显然，其尾数超过了24bit，根据舍入规则，尾数只取 100000000000000000010100，结果就造成测试中遇到的“奇怪”现象！131072.68 用单精度浮点数表示变成 131072.69 ，原因与此类似。实际上有效数字小于8位的数，浮点数也不一定能精确表示，7.22这个数的尾数就无法用24bit二进制表示，当然在数据库中测试不会有问题（舍入以后还是7.22），但如果参与一些计算，误差积累后，就可能产生较大的偏差。

二、mysql 和 oracle中的数值类型：   

    问题是不是只有 mysql 存在呢？
    显然不是，只要是符合IEEE754标准的浮点数实现，都存在相同的问题。     
    mysql中的数值类型（不包括整型）：   
    
    因此，在编程中应尽量避免做浮点数的比较，否则可能会导致一些潜在的问题！     
    除了这些，还应注意浮点数中的一些特殊值，如 NaN、+0、-0、+无穷、-无穷等，IEEE754虽然对此做了一些约定，但各具体实现、不同的硬件结构，也会有一些差异，如果不注意也会造成错误！
    
总结：   
从上面的分析，我们可以得出以下结论： 
1、浮点数存在误差问题；   
2、对货币等对精度敏感的数据，应该用定点数表示或存储；   
3、编程中，如果用到浮点数，要特别注意误差问题，并尽量避免做浮点数比较；   
4、要注意浮点数中一些特殊值的处理

```

### float double decimal
```
http://yongxiong.leanote.com/post/mysql_float_double_decimal

我们知道对于float类型的数据，只分配了32位的存储空间，对于double类型值分配了64位，但是并不是所有的实数都能转成32位
或者64位的二进制形式，如果超过了，就会出现截断，这就是误差的来源。 
比如将上面例子中的131072.32转成二进制后的数据为： 
100000000000000000.0101000111101011100001010001111010111000010100011111… 
这是一个无穷数，对于float类型，只能截取前32位进行存储，对于double只能截取前64位进行存储。所以 
131072.32保存为float类型是存储形式为：01001000000000000000000000010100; 
131072.32保存为double类型的格式为：0100000100000000000000000000001010001111010111000010100011110101

针对float情况，至少我们可以得出结论： 
1. 如果一个float型数据转成二进制后的第32位之后都是0，那么数据是准的 
2. 如果一个float型数据转成二进制后的第32位之后不全为0，则数据就会存在误差


如何选择float，double，decimal
1 如果你要表示的浮点型数据转成二进制之后能被32位float存储，或者可以容忍截断，则使用float，这个范围大概为要精确保存6位数字左右的浮点型数据 
比如10分制的店铺积分可以用float存储，小商品零售价格(1000块之内)

2 如果你要表示的浮点型数据转成二进制之后能被64位double存储，或者可以容忍截断，这个范围大致要精确到保存13位数字左右的浮点型数据 
比如汽车价格,几千万的工程造价

3 相比double，已经满足我们大部分浮点型数据的存储精度要求，如果还要精益求精，则使用decimal定点型存储 
比如一些科学数据，精度要求很高的金钱

理论上的东西永远比不上实践，应用场景大于一切理论。选择float或者double或者decimal有时候也要看场景，比如我们可以用double
存储一个小商铺的季度营业额（几千万），单独用double存储的时候没有问题，当多个季度，多个年份算总3年内的营业额是，就会出现
问题，再也算不出一个准确的答案。所以，如果考虑情况没那么有把握的情况下，推荐使用decimal，最后，也可以通过其他手段避开
这些问题，比如存储商品价格可以使用 乘于100的形式存储，展示价格的时候再除于100[完]

```

### char varchar text
```
注意!!!：char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。

CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中
不进行大小写转换。

BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符
串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。

BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于
可容纳存储范围不同。

有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。



1、 char长度固定， 即每条数据占用等长字节空间；适合用在身份证号码、手机号码等定。
2、 varchar可变长度，可以设置最大长度；适合用在长度可变的属性。
3、 text不设置长度， 当不知道属性的最大长度时，适合用text。

按照查询速度： char最快， varchar次之，text最慢。

char：char(n)中的n表示字符数，最大长度是255个字符； 如果是utf8编码方式， 那么char类型占255 * 3个字节。
（utf8下一个字符占用1至3个字节）

varchar：varchar(n)中的n表示字符数，最大空间是65535个字节， 存放字符数量跟字符集有关系；
     MySQL5.0.3以前版本varchar(n)中的n表示字节数；
     MySQL5.0.3以后版本varchar(n)中的n表示字符数；
```

###  int(4) 和 int(7)
```
drop table if exists userinfo;
create table `userinfo`(
	`id` int(4) unsigned ZEROFILL,
	`new_id` int(7) unsigned ZEROFILL
);

insert into `userinfo` values (123, 123);
insert into `userinfo` values (12345, 12345);
select * from userinfo;
//  可以看到int(4)里面的4只是显示宽度，如果有zerofill这个选项，会补足0，例如123，宽度是3，则补一个0，
//  如果超过宽度，例如12345宽度为5，超过4 ，则正常显示
mysql> select * from userinfo;
+-------+---------+
| id    | new_id  |
+-------+---------+
|  0123 | 0000123 |
| 12345 | 0012345 |
+-------+---------+
2 rows in set (0.00 sec)

```
