```
当从根本上理解时间复杂度的时候，排序算法就很容易理解!!!(时间复杂度是理解排序算法的前提)

```

###  等差数列等比数列求和
```
等比数列：
{A} = 3, -9, 27, -81, ......  //A数列共有n个数
sum(A) = 3 * (-9/3)^n-1 = a1 * q^n-1

等差数列：
{B} = 2, 4, 6, 8, 10  //B等差数列共有n个数,假设n是5
sum(B) = n(a1 + an)/2 = 5(2 + 10)/2 = 30

```

###  算法的时间复杂度
```
int i, j, n = 100;
for( i=0; i < n; i++ )
{
    for( j=i; j < n; j++ )
    {
        printf(“I love FishC.com\n”);
    }
}

由于当i=0时，内循环执行了n次，当i=1时，内循环则执行n-1次……当i=n-1时，内循环执行1次，所以总的执行次数应该是：
n+(n-1)+(n-2)+…+1 = n(n+1)/2
n(n+1)/2 = n^2/2+n/2
用我们推导大O的攻略，
第一条忽略，因为没有常数相加。
第二条只保留最高项，所以n/2这项去掉。
第三条，去除与最高项相乘的常数，最终得O(n^2)

--------------------------------------------------------------------------------------------------

int i = 1, n = 100;
while( i < n )
{
    i = i * 2;
}

1   2   2^1
2   4   2^2
4   8   2^3
8   16  2^4
16  32  2^5
32  64  2^6
64  128 2^7
结束循环

由2^x = n得到x = log(2)n，所以这个循环的时间复杂度为O(logn)。
具体上面的例子2^7 = 128，大于100,结束循环，总共执行了7次，也就是对等比数列的幂。
```
###  算法的空间复杂度
